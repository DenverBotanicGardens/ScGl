# adding in damping ratio and lifespan after first stage. 
```{r}
# graphics.off()
rm(list=ls())
library(dplyr)
library(popbio)
library(MuMIn)
library(binr)
library(matrixStats)
require(AICcmodavg)
library(prism)

```

"OK, here is what we'll do: I am going to send you some data source files and the attached R code. This code does a lot of stuff, but it is easiest to send it to you as a whole and tell you what lines to look at, I think." - Dan Doak




You will see between lines 1-38 some important summarizing of the sizes and survival rates for the recruits (these are 'bulblings', which are similar to seedlings for this spp). 
```{r}
sg <- read.csv(paste("Q:/Research/All_Projects_by_Species/Sclerocactus SPECIES/Sclerocactus_glaucus/R_code_ScGl/R_tables/RawData_scgl_2019.csv",
                   sep=""))  

setwd("C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3")
# setwd("C:/Users/Dan Doak/Desktop/CurrentProjects/IPMmodels/Bistorts")


### Load, manipulate, and sort data --------------

 # load('BNdataforIPM.RData')
 # write.csv(alldata,file='bistortdata.csv')
 # 
allsdszs= as.numeric(read.csv('bulblingsizes.csv', header=FALSE)[,1])
mnsldgsz=mean(allsdszs)
sdsldgsz = sqrt(var(allsdszs))

allsdszs_scgl <- sg$Width.cm.[which(sg$Width.cm. < 0.6 & sg$Width.cm. > 0.01 & !is.na(sg$Width.cm.))]
mnsldgsz_scgl <- mean(allsdszs_scgl)
sdsldgsz_scgl <- sqrt(var(allsdszs_scgl))

alldata=as.matrix(read.csv('BNdataforIPMsimple.csv', header=TRUE))
#alldata has columns of: szs0, szs1, bulbils produced in yr 0
alldata=as.data.frame(alldata)
alldata=alldata[which(is.na(alldata[,1])==FALSE),]

alldata$survival = 1
alldata$survival[which(alldata$szs1==0)] = 0
alldata$szs1[which(alldata$szs1==0)] = NA
alldata=alldata[which(alldata$szs0 !=0),]

bulblings_per_bulbil = 0.00676 # this is mean for allyrs and the 4 niwot pops, from 
#data assembled for Sam analyses

seed_per_flower <- 100 # estimate from few times collected seed from flowers

# define size of a bulbling as =sqrt(4.388*2*2) = 2
bulblingsz=sqrt(4.388*4)
minisz <- 0.5
# say that survival of bulblings is survial for plants of <= 2,2,size:
alltinys=alldata[alldata$szs0<=bulblingsz,]
surv_bulbings=sum(alltinys$survival)/length(alltinys$survival)

# for scgl, we started in 2012 or so just counting minis, not recording size but did before (and occasionally after)
# allminis <- sg[sg$Width.cm. <= minisz,] # need to do this after I've got year to year transitions
# surv_mini_1 <- sum() # Survival should just be averaged with the estmiate of after we started just counting and my estimate of how many grew (so survived) and how many died and how many survived or how many new ones there might be

```

# mimic with ScGl
```{r}

sg <- sg[which(complete.cases(sg[,c("Tag")])),]
# sg[which(sg$Width.cm. < 2.5 & sg$Fl == "y"),]

sg$Width.cm.[sg$Year == 2017 & sg$Tag==363.00] <- 4.4
# sg$Height.cm.[sg$Year == 2017 & sg$Tag==363.00] <- 1
sg$Width.cm.[which(sg$Year == 2013 & sg$Tag==1242)] <- 11.8 
sg$Width.cm.[which(sg$Year == 2009 & sg$Tag==96)] <- 9.8 

sg$Fl[which(sg$Width.cm. < 2.5 & sg$Fl == "y")] <- "n"
```

```{r}
sg_ipm <- subset(merge(sg[,c(2:5,10:14)], sg[,c(2:5,10:14)], by = c("Site","Tag","Transect")), Year.x == Year.y - 1)

allminis <- sg_ipm[sg_ipm$szs0 <= minisz,]
surv_minis1 <- sum(allminis$survival)/length(allminis$survival) # estimate survival of minis from when we didn't just count

names(sg_ipm)[names(sg_ipm) == "Width.cm..x"] <- "szs0"
names(sg_ipm)[names(sg_ipm) == "Width.cm..y"] <- "szs1"
# minis are less than 0.5 height
names(sg_ipm)[names(sg_ipm) == "Minis.x"] <- "minis0"
names(sg_ipm)[names(sg_ipm) == "Minis.y"] <- "minis1" # recruitment

sg_ipm <- sg_ipm[which(sg_ipm$szs0!=0),]

sg_ipm$survival <- 1
sg_ipm$survival[which(sg_ipm$szs1==0)] <- 0 
table(sg_ipm$survival)

# minis are recruitment, some are lost the next year because they grow, some die. If there are more the next year, could be from a different tag (associated wrong or difference, should sum by truncated tag number)

sg_ipm$MainTag <- floor(sg_ipm$Tag)
minispertag0 <- aggregate(minis0 ~ MainTag + Year.x + Transect + Site,
                         data = sg_ipm,
                         sum)
minispertag1 <- aggregate(minis1 ~ MainTag + Year.y + Transect + Site,
                         data = sg_ipm,
                         sum)
minis0to1 <- subset(merge(minispertag0, minispertag1, by = c("MainTag","Transect","Site")), Year.x == Year.y -1)
minis0to1$minichange <- minis0to1$minis1-minis0to1$minis0

require(reshape2)
minismelt <- melt(minis0to1, id.var = c("MainTag", "Transect", "Site", "Year.x", "Year.y"))

ggplot(minismelt, aes(variable, value))+
  geom_boxplot()

# There would be more individuals that are added to a tag if the decrease in number are ones that grew bigger. 
# numpertag <- aggregate(cbind(count = MainTag) ~ MainTag+Transect+Site+Year.x+Year.y, data=sg_ipm, FUN = function(x){NROW(x)})
# numpertag[numpertag$count>1,]
sg[is.na(sg$Height.cm.),]

sg$MainTag <- floor(sg$Tag)
# Ignore dead tags
numpertagperyear <- aggregate(cbind(count = MainTag) ~ MainTag+Transect+Site+Year, data=sg[!is.na(sg$Height.cm.),], FUN = function(x){NROW(x)})
numpertagperyear[with(numpertagperyear, order(MainTag, Transect, Site, Year)),]
numpertag <- subset(merge(numpertagperyear, numpertagperyear,  by = c("Site","MainTag","Transect")), Year.x == Year.y - 1)
hist(numpertag$count.y-numpertag$count.x) # how many in t+1 from t year. So some die
numpertag$NewIndiv <- numpertag$count.y-numpertag$count.x
```
When you get additional minis and you've got some new tagged plants (minis growing larger than 0.5 width) then you've gained additional minis - so gain or lose minis, when some are documented as newly larger than 0.5 cm, that is surviving individuals from the mini category.       
Minis are easy to miss, might be why start measuring and add tag when not first year so survived > minis0          
Could count it as 100% survived if survived is >=1 and if some died, a percent, so (minis0+survived)/minis0 (when survived is <0)    
if there are more the next year, assume all survived and some new ones found, 100% survival     
When some died or grew, subtract the ones that are new individuals. minichange plut newindiv is the number of minis that likely died or that were added so then conservative is 100% survival, after accounting for growth, the minichange that is negative would be survival of (minis0+minichange)/minis0        


```{r}
# numpertag; minis0to1
minis0to1 <- merge(minis0to1, numpertag, by = c("MainTag","Transect","Site", "Year.x","Year.y"))
minis0to1[with(minis0to1, order(MainTag, Transect, Site, Year.x)),]
# If nimichange is negative, this could be accounted for with an increase in NewIndiv or due to death of minis. So should be conservative and say survival by adding new individuals (only positive values). NewIndiv being negative would be bigger than minis dying. Trying to get to death of minis, subtract out growth of minis
# minichange is death, so ones that grew need to be subtracted from death or added to change but only when change is negative and newindiv is positive
minis0to1$survived <- (minis0to1$minis0 + minis0to1$minichange)/minis0to1$minis0
# when there are new sub tags, new plants, NewIndiv, the negative survived ones assume became full plants. 
minis0to1$survived[minis0to1$survived>1] <- 1

surv_minis2 <- mean(minis0to1$survived, na.rm = TRUE)

surv_minis <- mean(c(surv_minis2, surv_minis1))
```



####################################################
```{r}
lifespan <- function(nx){
  nclasses=dim(nx)[1]
  vec=c(100,rep(0,(nclasses-1)))
  nx[1,]=0
  jj=1
  while (sum(vec)>1){
    vec=nx%*%vec
    jj=jj+1
    #print(sum(vec))
  }
  return(jj)
}
```
#############################################


```{r}
minsize <- min(c(alldata[,1],alldata[,2]), na.rm=TRUE) -0.1
#maxsize <- max(c(alldata[,1],alldata[,2]), na.rm=TRUE) +0.1
maxsize=60 # this is set manually to not have a large category at end that has no plants.
alldata[which(alldata[,1]>maxsize),1]=maxsize
alldata[which(alldata[,2]>maxsize),2]=maxsize

# ScGl
sg_ipm$szs1[sg_ipm$szs1==0] <- NA
sg_ipm <- sg_ipm[!is.na(sg_ipm$szs0),]
minsize_scgl <- min(c(sg_ipm$szs0,sg_ipm$szs1), na.rm = TRUE) - 0.09
maxsize_scgl <- max(c(sg_ipm$szs0,sg_ipm$szs1), na.rm = TRUE) + 0.01
size_scgl <- sg_ipm[,c("Site","Transect","szs0","szs1","minis0","survival","Fl.x")]

table(size_scgl$Fl.x)
size_scgl$Fl.x <- as.character(size_scgl$Fl.x)
size_scgl$Fl.x[size_scgl$Fl.x == "n"] <- "0"
size_scgl$Fl.x[size_scgl$Fl.x == "y"] <- "1"
size_scgl$Fl.x <- as.numeric(size_scgl$Fl.x)

colnames(size_scgl) <- c("Site", "Transect", "t0","t1","minis0","survival","reproyesno")
```
ScGl doesn't have bulbs, it has flowers that grow into minis, and there is some relationship between the number of flowers and the size of the plant.

```{r}
sg[sg$Year == 2019,] # where we co-opted photo number for number of flowers
Photo2Flower <- sg$PhotoNumber[sg$Year==2019]
Photo2Flower <- as.numeric(sapply(Photo2Flower, function(x) gsub("[^0-9.-]", "", x)))
sg[sg$Year==2019,][which(Photo2Flower>11),]
# fix the nonsense ones
sg$PhotoNumber <- as.character(sg$PhotoNumber)
sg$PhotoNumber[sg$PhotoNumber=="2=11"] <- "11"
sg$PhotoNumber[sg$PhotoNumber=="4, 1 damaged"] <- "4"
sg$PhotoNumber[grep("NOTE there are",sg$PhotoNumber)] <- "0"
# Now re-run Photo2Flower
Photo2Flower <- sg$PhotoNumber[sg$Year==2019]
Photo2Flower <- as.numeric(sapply(Photo2Flower, function(x) gsub("[^0-9.-]", "", x)))
sg[sg$Year==2019,][which(Photo2Flower>11),]

sg$PhotoNumber[sg$Year==2019] <- Photo2Flower
sg2019 <- sg[sg$Year==2019,]
sg2019$PhotoNumber <- as.numeric(sg2019$PhotoNumber)

# If flowering, then here's how width relates to number of flowers
ggplot(sg2019[sg2019$Fl=="y",], aes(Width.cm., PhotoNumber))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_bw()#+
  # facet_wrap(~Site, nrow=3)

summary(lm(PhotoNumber~Width.cm.+I(Width.cm.^2), data=sg2019[sg2019$Fl=="y",]))

summary(lm(PhotoNumber~Width.cm., data=sg2019[sg2019$Fl=="y",])) # y = 1.26x+ -3.86 +StErr 0.06
```

```{r}
size=alldata
colnames(size)=c('t0','t1','bulbs0','survival')

table(size$bulbs0)

size$reproyesno = size$bulbs0
size$reproyesno[size$reproyesno >0]=1 # so, turn into yes no variable
sizeforrepro=size
sizeforrepro=sizeforrepro[sizeforrepro$reproyesno==1,]

#################### ScGl #################### 
sizeforrepro_scgl <- size_scgl[size_scgl$reproyesno==1,]
sizeforrepro_scgl$flowers0 <- sapply(sizeforrepro_scgl$t0, function(x){ 
  # rnorm(1, mean = 1.26*x - 3.86, sd = 0.06*sqrt(nrow(sizeforrepro_scgl)-2))
  rpois(1, 1.26*x - 3.86)
  })
# size_scgl; sizeforrepro_scgl
size_scgl <- merge(size_scgl, sizeforrepro_scgl, 
                   by = c("Site","Transect","t0","t1","minis0","survival","reproyesno"))
#################### #################### 


#####new size density estimation for median size estimation
pdfsz=density(size$t0, n=1024, cut=0)
pdfsz2=cbind(pdfsz$x,pdfsz$y)
#so, this is a set of smoothed values that can then be used with weightedMedian in the matrixStats package to get a 'good' median for each class.
######---------------
plot(pdfsz2)

#ScGl
pdfsz_scgl <- density(size_scgl$t0, n=1024, cut=0, na.rm = TRUE)
pdfsz2_scgl <- cbind(pdfsz_scgl$x,pdfsz_scgl$y)


plot(pdfsz2, type="l")
plot(pdfsz2_scgl, type="l")
```

### Specify what range of classes/bins to evaluate -----------------------
```{r}
bin.num <- c(3,4,5,6, 8, 10,seq(from = 15, to = 100, by = 10))
#bin.num=20
```
### Matrix Model ------------------------


## Estimate vital rates, populate matrix, for models with different numbers 
## of classes/ bins   
```{r}
lambdas_matrix <- rep(NA, length(bin.num))
dampratio_matrix = rep(NA, length(bin.num))
lifespan_matrix=rep(NA, length(bin.num))
mincounts=NULL

for(i in 1:length(bin.num)){
  ss=as.numeric(size$t0)
  # vbin = bins(size$t0, target.bins=bin.num[i], max.breaks = bin.num[i]+1, exact.groups = F, verbose = F, errthresh = 0.1, minpts = NA)
  # vec.bin <- bins.getvals(vbin)
  # vec.bin[1] <- minsize
  vec.bin = c(minsize, minsize+1:bin.num[i]*(maxsize-minsize)*(1/bin.num[i]))  
  nums=hist(ss,breaks=vec.bin, plot=FALSE)$counts 
  mincounts=c(mincounts,min(nums))
  
  if (min(nums)>2) {  
    ## Initialize storage
    n.bin <- length(vec.bin)-1                  # this is a workaround
    n <- rep(NA, n.bin)                         # count of indvs per bin
    medians <- rep(NA, n.bin)                    # median size per bin for F
    surv <- rep(NA, n.bin)                      # survivorship for each class
    grow <- matrix(NA, n.bin, n.bin)            # store growth probabilites for each class
    reproduction <- rep(NA, n.bin)
    
    totnums = 0 # this is just monitoring for errors
    # bin, survival, growth
    for(j in 1:(length(vec.bin)-1)){
      # set limits for subset according to bin breaks
      bounds <- c(vec.bin[j], vec.bin[j+1])
      # subset data according to bounds
      subset <- size[size$t0 > bounds[1] & size$t0 <= bounds[2],]
      # store number of inviduals in this bin for future reference
      n[j] <- length(subset$t0)
      medians[j] <- median(subset$t0)
      # calculate survivorship for this class
      surv[j] <- sum(subset$survival) / length(subset$t0)
      # store histo as object, to access counts per bin
      histo <- hist(subset$t1, breaks = vec.bin, plot = FALSE)
      # $counts returns the number of individuals of a certain size class
      grow[,j] <- histo$counts/length(subset$t0[subset$survival==1]) 
      reproduction[j] <- mean(subset$bulbs0) # bulbils produced per plant in start yr
      
      totnums = totnums + sum(histo$counts)
    }
    
    # make a vector of the prob of seedling sizes: 
    sdlggrow=hist(allsdszs , breaks = vec.bin, plot = FALSE)$counts/length(allsdszs)
    
    M1 <- matrix(NA, n.bin, n.bin)   # initiate projection matrix
    M <- matrix(0, (n.bin+1), (n.bin+1))
    # populate projection matrix
  
    for(j in 1:length(surv)){
      M1[,j] <- surv[j] * grow[,j]
      M1[,j] <- (surv[j] * grow[,j])
    }
      
      # add lines for the creation of bulblings and thier transition to first size class
      M[2:(n.bin+1), 2:(n.bin+1)] = M1
      M[2:(n.bin+1),1] = surv_bulbings*sdlggrow 
      M[1,2:(n.bin+1)] = reproduction*bulblings_per_bulbil  
    
    
    lambdas_matrix[i] <- lambda(M) # calls popbio f'n 'lambda'
    dampratio_matrix[i]=damping.ratio(M)
    lifespan_matrix[i] =lifespan(M)
    
    print(c(i,totnums)) 
  } else {
    lambdas_matrix[i]=NA
    dampratio_matrix[i] = NA
    lifespan_matrix[i] = NA
  }
}
```

### Specify what range of classes/bins to evaluate -----------------------
```{r}
bin.num <- c(3,4,5,6)
#bin.num=20
```

ScGl
```{r}
lambdas_matrix <- rep(NA, length(bin.num))
dampratio_matrix = rep(NA, length(bin.num))
lifespan_matrix=rep(NA, length(bin.num))
mincounts=NULL

#test 
# i<-3 # at 5 size bins, still have more than 2 in each class
# mincounts<- NULL
# rm(vec.bin)
# breaks it into 3-95 size bins (by bin.num)
for(i in 1:length(bin.num)){
  ss=as.numeric(size_scgl$t0)
  # vec.bin = c(minsize_scgl, minsize_scgl+1:bin.num[i]*(maxsize_scgl-minsize_scgl)*(1/bin.num[i]))  # really should split at < 0.6 and then < 2.5 as the non-reproductive sizes, then split above
  breaks2add <- minsize_scgl+1:(bin.num[i])*(maxsize_scgl-minsize_scgl)*(1/(bin.num[i]))
  vec.bin <- c(minsize_scgl, 2.5, breaks2add[3:(bin.num[i])])
  nums=hist(ss,breaks=vec.bin, plot=FALSE)$counts 
  mincounts=c(mincounts,min(nums))
  
  if (min(nums)>2) {  
    ## Initialize storage
    n.bin <- length(vec.bin)-1                  # this is a workaround
    n <- rep(NA, n.bin)                         # count of indvs per bin
    medians <- rep(NA, n.bin)                    # median size per bin for F
    surv <- rep(NA, n.bin)                      # survivorship for each class
    grow <- matrix(NA, n.bin, n.bin)            # store growth probabilites for each class
    reproduction <- rep(NA, n.bin)
    
    totnums = 0 # this is just monitoring for errors
    # bin, survival, growth  test j<-4
     for(j in 1:(length(vec.bin)-1)){
      # set limits for size subset according to bin breaks
      bounds <- c(vec.bin[j], vec.bin[j+1])
      # subset data according to bounds
      subset <- size_scgl[size_scgl$t0 > bounds[1] & size_scgl$t0 <= bounds[2],]
      # store number of inviduals in this bin for future reference
      n[j] <- length(subset$t0)
      medians[j] <- median(subset$t0)
      # calculate survivorship for this class
      surv[j] <- sum(subset$survival) / length(subset$t0)
      # store histo as object, to access counts per bin
      histo <- hist(subset$t1, breaks = vec.bin, plot = FALSE)
      # $counts returns the number of individuals of a certain size class
      grow[,j] <- histo$counts/length(subset$t0[subset$survival==1]) 
      reproduction[j] <- mean(subset$flowers0, na.rm = TRUE) # bulbils produced per plant in start yr - not the same for ScGl, minis aren't produced, not the same as fruit count, which we didn't take or seed count - so estimate how many flower there would likely have been; but there aren't going to be any flowers until >2.5 width
      
      totnums = totnums + sum(histo$counts)
    }
    
    # make a vector of the prob of seedling sizes: 
    sdlggrow <- hist(allsdszs_scgl, breaks = vec.bin, plot = FALSE)$counts/length(allsdszs_scgl)
    reproduction[is.nan(reproduction)] <- 0
    
    M1 <- matrix(NA, n.bin, n.bin)   # initiate projection matrix
    M <- matrix(0, (n.bin+1), (n.bin+1))
    # populate projection matrix
  
    for(j in 1:length(surv)){
      M1[,j] <- surv[j] * grow[,j]
      M1[,j] <- (surv[j] * grow[,j])
    }
      
      # add lines for the creation of bulblings and thier transition to first size class
      M[2:(n.bin+1), 2:(n.bin+1)] = M1
      M[2:(n.bin+1),1] = surv_minis*sdlggrow 
      M[1,2:(n.bin+1)] = reproduction*seed_per_flower  
    
    
    lambdas_matrix[i] <- lambda(M) # calls popbio f'n 'lambda'
    dampratio_matrix[i]=damping.ratio(M)
    lifespan_matrix[i] =lifespan(M)
    
    print(c(i,totnums)) 
  } else {
    lambdas_matrix[i]=NA
    dampratio_matrix[i] = NA
    lifespan_matrix[i] = NA
  }
}
```

Climate and ScGl
```{r}
options(prism.path = "Q:/Research/All_Projects_by_Species/Sclerocactus SPECIES/Sclerocactus_glaucus/ScGl_climate")


```



Lines 170-215: this is doing what you could also do with dredge, but that simpler here: getting a predictive model (as a function only of size in this case) for each demographic rate: survival, mean growth, variance in growth, prob of reproducing, and how much reproduction if reproducing. The code fits a few alternatives and chooses the best one for each rate, which will be used below. 

#######################################
######################################
### IPM with mean sizes-----------------------------------------------------
```{r}
# adding in columns
size$t0sq <- size$t0^2           
sizeforrepro$t0sq = sizeforrepro$t0^2

# Add columns for ScGl squaring the size terms, why for?? - oh! to give some curve to the 
size_scgl$t0sq <- size_scgl$t0^2
sizeforrepro_scgl$t0sq <- sizeforrepro_scgl$t0^2

# fitting functions for different vital rates (survival, growth, reproduction)
# prob (survival): linear function of size, quadratic function of size
sur_models <- list(glm(survival~ t0, family= "binomial",data = size),
                   glm(survival~ t0 + t0sq , family= "binomial",data =size))
# gives the value of the lowest AICc
min_AIC <- min(MuMIn::AICc(sur_models[[1]], sur_models[[2]])$AICc)
# gives you the info for the best-fit model
bestsur <- sur_models[[which(min_AIC == MuMIn::AICc(sur_models[[1]], sur_models[[2]])$AICc)]] 

######### ScGl survival #########################
# do it my way 

glm1 <- glm(survival ~ t0, family = "binomial", data = size_scgl)
glm2 <- glm(survival ~ t0 + t0sq, family = "binomial", data = size_scgl)
glm3 <- glm(survival ~ t0 + Site + t0*Site, family = "binomial", data = size_scgl) # The slope and the intecept could differ
glm4 <- glm(survival ~ t0*Site, family = "binomial", data = size_scgl)

lm.list <- list(glm1, glm2, glm3, glm4)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))
# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}
################################################
 
ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  stat_smooth(se = FALSE)+
  theme_bw()

ggplot(size_scgl, aes(t0, survival))+
  geom_point()+
  stat_smooth(se = FALSE)+
  theme_bw()
```

```{r}
# growth: linear function of size, quadratic function of size, power function (A+B*(size^C))
growth_models <- list(nls(t1~ a+ b*t0, data = size, start=list(a= 1, b=1)),
                      nls(t1~ a+ b*t0 + c*t0sq, data = size, start=list(a= 1, b=1,c=1)),
                      nls(t1 ~ a + b*(t0^c), data= size, start=list(a= 1, b=1,c=1)))
# gives the value of the lowest AICc
min_AIC <- min(MuMIn::AICc(growth_models[[1]], growth_models[[2]],growth_models[[3]])$AICc)
# gives you the info for the best-fit model
bestgrowth <- growth_models[[which(min_AIC == MuMIn::AICc(growth_models[[1]], growth_models[[2]], growth_models[[3]])$AICc)]]

# getting residuals of growth
size$growth_residuals <- NA
size$growth_residuals[which(!is.na(size$t1) & !is.na(size$t0))] <- summary(bestgrowth)$residuals^2

# s <- seq(from = 0, to = 60, length = 11332) # length(size$t0))
# plot(t1~t0, data=size)
# abline(lm(t1~t0, data=size), col="red")
# lines(s, predict(nls(t1~ a+ b*t0, data = size, start=list(a= 1, b=1)), list(x=s)), col="green")
# lines(s, predict(nls(t1~ a+ b*t0 + c*t0sq, data = size, start=list(a= 1, b=1,c=1)), list(x=s)), col="blue")
# lines(s, predict(nls(t1 ~ a + b*(t0^c), data= size, start=list(a= 1, b=1,c=1)), list(x=s)), col="yellow")
# plot(t1~t0, data=size_scgl)
# abline(lm(t1~t0, data=size_scgl), col="red")

########### ScGl growth #################
# nls {stats} is for curve fitting. 
nlm1 <- nls(t1 ~ a + b*t0, data = size_scgl, start = list(a=1, b=1))
nlm2 <- nls(t1 ~ a + b*t0 + c*t0sq, data=size_scgl, start = (list(a=1, b=1, c=1)))
nlm3 <- nls(t1 ~ a + b*(t0^c), data=size_scgl, start=list(a=1, b=1, c=1))

nlm.list <- list(nlm1, nlm2, nlm3)
nlm.names <- as.character(unlist(lapply(nlm.list, formula)))
(nlm.results <- aictab(nlm.list, modnames = nlm.names))
for(i in 2:length(nlm.list)){
  print(exp(0.5*nlm.results$Delta_AICc[i]))
}

size_scgl$growth_residuals <- NA
size_scgl$growth_residuals[which(!is.na(size_scgl$t1) & !is.na(size_scgl$t0))] <- summary(nlm1)$residuals^2 # so the variance squared
#########################################

plot(growth_residuals~t0, data=size_scgl, pch=16)
plot(t1~t0, data=size_scgl, pch=16)

```


```{r}

reproyesno_models <- list(glm(reproyesno~ t0, family= "binomial",data = size),
                   glm(reproyesno~ t0 + t0sq , family= "binomial",data =size))
# gives the value of the lowest AICc
min_AIC <- min(MuMIn::AICc(reproyesno_models[[1]], reproyesno_models[[2]])$AICc)
# gives you the info for the best-fit model
bestreproyesno <- reproyesno_models[[which(min_AIC == MuMIn::AICc(reproyesno_models[[1]], reproyesno_models[[2]])$AICc)]]
# yes/no repro: logistic: 

# reproduction if reproducing: linear function of size, quadratic function of size, 
rep_models <- list(lm(bulbs0~ t0, data = sizeforrepro),
                    lm(bulbs0~ t0+ t0sq, data = sizeforrepro)) 
min_AIC <- min(MuMIn::AICc(rep_models[[1]], rep_models[[2]])$AICc)# gives the value of the lowest AICc
(bestrep <- rep_models[[which(min_AIC == MuMIn::AICc(rep_models[[1]], rep_models[[2]])$AICc)]]) # gives you the info for the best-fit model

###################### ScGl when reproductive ##########################
glm.rp1 <- glm(reproyesno ~ t0, family = "binomial", data = size_scgl, maxit = 100) # 
glm.rp2 <- glm(reproyesno ~ t0 + t0sq, family = "binomial", data = size_scgl)

glm.rp.list <- list(glm.rp1, glm.rp2)
glm.rp.names <- as.character(unlist(lapply(glm.rp.list, formula)))
(glm.rp.results <- aictab(glm.rp.list, modnames = glm.rp.names))
for(i in 2:length(glm.rp.list)){
  print(exp(0.5*glm.rp.results$Delta_AICc[i]))
}
#######################################################


###################### ScGl how many seeds when when reproductive ##########################
rep1 <- lm(flowers0 ~ t0, data = sizeforrepro_scgl) # don't need to find best model, this is based on a lm I set up
summary(rep1)

############################################################################################
```


```{r}
# variance in growth: uses best-fit model for growth: linear function of size, quadratic function of size, no intercept
var_models <- list(glm(growth_residuals~ t0-1, data= size), glm(growth_residuals~ t0 + t0sq-1, data= size))
min_AIC <- min(MuMIn::AICc(var_models[[1]], var_models[[2]])$AICc) # gives the value of the lowest AICc
bestvar <- var_models[[which(min_AIC == MuMIn::AICc(var_models[[1]], var_models[[2]])$AICc)]] # gives you the info for the best-fit model


################## ScGl ##################
var1 <- glm(growth_residuals ~ t0-1, data = size_scgl)
var2 <- glm(growth_residuals ~ t0 + t0sq-1, data = size_scgl)

var.list <-  list(var1, var2)
var.names <- as.character(unlist(lapply(var.list, formula)))
(var.results <- aictab(var.list, modnames = var.names))
for(i in 2:length(var.list)){
  print(exp(0.5*var.results$Delta_AICc[i]))
}
##########################################
```




Line 225: everything below in this section is in a loop that varies how many bins (size classes) are used to make the model: this is what this code is for, but that is not something that you need to do, so don't worry about this, except to know that you do need to define how many bins you will use. 

```{r}
# vary bin sizes

lambdas_ipm_mean <- vector("numeric", length= length(bin.num))
dampratio_mean = vector("numeric", length= length(bin.num))
lifespan_mean = vector("numeric", length= length(bin.num))

truebinsizes= matrix(0,length(bin.num),1)

for (i in 1:length(bin.num)){

  # vbin = bins(size$t0, target.bins=bin.num[i], max.breaks = bin.num[i]+1, exact.groups = F, verbose = F,     errthresh = 0.1, minpts = NA)
  # vec.bin <- bins.getvals(vbin)
  # vec.bin[1] <- minsize
  # vec.bin[length(vec.bin)]=maxsize

  # Line 232: this is defining the size boundaries between classes, and the next uncommented line is getting the mid-bin sizes. 
  vec.bin = c(minsize, minsize+1:bin.num[i]*(maxsize-minsize)*(1/bin.num[i])) 

  #--- either do the first block to make medians the focal estimated size for each cat, or do the second line, to define as the mean of the breakpts:
  # binmids =   rep(NA, length(vec.bin)-1) 
  # for(jj in 1:(length(vec.bin)-1)){
  #   # set limits for subset according to bin breaks
  #   bounds <- c(vec.bin[jj], vec.bin[jj+1])
  #   # subset data according to bounds
  #   subset <- size[size$t0 >= bounds[1] & size$t0 < bounds[2],]
  #   binmids[jj] <- median(subset$t0)
  # }
  
  binmids <- 0.5*(vec.bin[2:length(vec.bin)] + vec.bin[1:(length(vec.bin)-1)])
  #--------------------------------------------------------------------
  
  
# Lines 249- 275 **to end of ss loop**. This is the section that makes predictions of each vital rate for each size class. the ss loop (starting on line 269) does this for the growth rates, which results in a matrix of values, as it is the probability of growing from each size to each other one. 
  n.bin = length(binmids)
  truebinsizes[i] = n.bin  
  
  # constructing matrix models
  indata <- as.data.frame(cbind(binmids, binmids^2))
  names(indata) <- c("t0", "t0sq")
  
  sur_vals <- predict(bestsur,indata, type='response')
  reproyesnovals=predict(bestreproyesno, indata, type='response')
  rep_vals <- predict(bestrep, indata, type='response')
  rep_vals[rep_vals<0] <- 0
  growth_vals <- predict(bestgrowth,indata, type='response')
  var_vals <- predict(bestvar,indata, type='response')
  gmx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
   
  sdlgszcdf=pnorm(vec.bin,mnsldgsz,sdsldgsz)
  sdlgszprobs=sdlgszcdf[2:length(vec.bin)]-sdlgszcdf[1:(length(vec.bin)-1)]
  sdlgszprobs=sdlgszprobs/sum(sdlgszprobs)
  
  # growth probs using cdf fn
  for (ss in 1:(n.bin)) {
    growcdf <- pnorm(vec.bin,growth_vals[ss],sqrt(var_vals[ss]))
    grows <- growcdf[2:length(vec.bin)]-growcdf[1:(length(vec.bin)-1)]
    if(sum(grows)>0){grows <- grows/sum(grows)
                     gmx[,ss] <- grows} else {gmx[,ss] <- NA} 
    # this if statement breaks the code (puts NA's into the matrix) if the sum of the PDF is zero (which happens if all the probability is outside of the size bounds)
  } # end ss loop
  ##########################
  
  
# Line 278: this makes the matrix of growth * survival rates. this is the entire matrix except the first row and the first column, which concern reproduction and new recruits
  # make the surv*growth mx
  survgmx <- gmx*t(matrix( rep(sur_vals,(n.bin)),(n.bin))) # survs* growth
  reprow <- rep_vals*reproyesnovals #*bulblings_per_bulbil 
 
  mx1 <- survgmx # growth and survival, without the repro
  
  mx <- matrix(0, (n.bin+1), (n.bin+1))
   mx[2:(n.bin+1), 2:(n.bin+1)] = mx1
   
# Lines 285 and 287: these make the first row and column, with reproduction and then the size probabilities of the new bulblings. These are added in to make the final matrix
   mx[2:(n.bin+1),1] = surv_bulbings*sdlgszprobs
   
 mx[1,2:(n.bin+1)] = reprow*bulblings_per_bulbil  
 
 
  lambdas_ipm_mean[i] <- Re(eigen(mx)$values[1])
  dampratio_mean[i]= damping.ratio(mx)
  lifespan_mean[i] =lifespan(mx)
 print(i)
}

```
#######################################
######################################

################ ScGl #################
```{r}
# vary bin sizes, or not

bin.num <- 6

lambdas_ipm_mean <- vector("numeric", length= length(bin.num))
dampratio_mean = vector("numeric", length= length(bin.num))
lifespan_mean = vector("numeric", length= length(bin.num))

truebinsizes= matrix(0,length(bin.num),1)

for (i in 1:length(bin.num)){

# for 3-5 bins, doesn't split at reproductive size
  vec.bin = c(minsize_scgl, minsize_scgl+1:bin.num[i]*(maxsize_scgl-minsize_scgl)*(1/bin.num[i])) 

  # previous makes the focal estimate at 2cm where there's a clear cut off around 2.5 for reproductive or not, I think a clean break (the following) is better
  binmids <- 0.5*(vec.bin[2:length(vec.bin)] + vec.bin[1:(length(vec.bin)-1)])
  #--------------------------------------------------------------------
  
# Lines 249- 275 **to end of ss loop**. This is the section that makes predictions of each vital rate for each size class. the ss loop (starting on line 269) does this for the growth rates, which results in a matrix of values, as it is the probability of growing from each size to each other one.   
  n.bin = length(binmids)
  truebinsizes[i] = n.bin  
  
  # constructing matrix models
  indata <- as.data.frame(cbind(binmids, binmids^2))
  names(indata) <- c("t0", "t0sq")
  
  # my bestsur was glm1
  sur_vals <- predict(glm1, indata, type='response')
  reproyesnovals=predict(glm.rp1, indata, type='response') # this should be yes or no
  rep_vals <- predict(rep1, indata, type='response') # this is by size bulb something... I have flowers by size, assuming each flower makes about 100 seed
  rep_vals[rep_vals<0] <- 0
  growth_vals <- predict(nlm1,indata, type='response')
  var_vals <- predict(var1,indata, type='response')
  gmx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
   
  sdlgszcdf=pnorm(vec.bin,mnsldgsz_scgl,sdsldgsz_scgl)
  sdlgszprobs=sdlgszcdf[2:length(vec.bin)]-sdlgszcdf[1:(length(vec.bin)-1)]
  sdlgszprobs=sdlgszprobs/sum(sdlgszprobs)
  
  # growth probs using cdf fn
  for (ss in 1:(n.bin)) {
    growcdf <- pnorm(vec.bin,growth_vals[ss],sqrt(var_vals[ss]))
    grows <- growcdf[2:length(vec.bin)]-growcdf[1:(length(vec.bin)-1)]
    if(sum(grows)>0){grows <- grows/sum(grows)
                     gmx[,ss] <- grows} else {gmx[,ss] <- NA} 
    # this if statement breaks the code (puts NA's into the matrix) if the sum of the PDF is zero (which happens if all the probability is outside of the size bounds)
  } # end ss loop
  
  # make the surv*growth mx
  survgmx <- gmx*t(matrix( rep(sur_vals,(n.bin)),(n.bin))) # survs* growth
  reprow <- rep_vals*reproyesnovals #*bulblings_per_bulbil 
 
  mx1 <- survgmx # growth and survival, without the repro
  
  mx <- matrix(0, (n.bin+1), (n.bin+1))
   mx[2:(n.bin+1), 2:(n.bin+1)] = mx1
   mx[2:(n.bin+1),1] = surv_minis*sdlgszprobs
   
 mx[1,2:(n.bin+1)] = reprow*seed_per_flower  
 
 
# Lines 290-292: these are just getting lambda and other outputs from the now-created matrix. 

  lambdas_ipm_mean[i] <- Re(eigen(mx)$values[1])
  dampratio_mean[i]= damping.ratio(mx)
  lifespan_mean[i] =lifespan(mx)
 print(i)
}

# four values because testing 3:6 size classes. 
```

########################################
########################################



### IPM with median sizes-----------------------------------------------------
```{r}
# adding in columns
size$t0sq <- size$t0^2           
sizeforrepro$t0sq = sizeforrepro$t0^2
# fitting functions for different vital rates (survival, growth, reproduction)
# prob (survival): linear function of size, quadratic function of size
sur_models <- list(glm(survival~ t0, family= "binomial",data = size),
                   glm(survival~ t0 + t0sq , family= "binomial",data =size))
# gives the value of the lowest AICc
min_AIC <- min(MuMIn::AICc(sur_models[[1]], sur_models[[2]])$AICc)
# gives you the info for the best-fit model
bestsur <- sur_models[[which(min_AIC == MuMIn::AICc(sur_models[[1]], sur_models[[2]])$AICc)]] 

# growth: linear function of size, quadratic function of size, power function (A+B*(size^C))
growth_models <- list(nls(t1~ a+ b*t0, data = size, start=list(a= 1, b=1)),
                      nls(t1~ a+ b*t0 + c*t0sq, data = size, start=list(a= 1, b=1,c=1)),
                      nls(t1 ~ a + b*(t0^c), data= size, start=list(a= 1, b=1,c=1)))
# gives the value of the lowest AICc
min_AIC <- min(MuMIn::AICc(growth_models[[1]], growth_models[[2]],growth_models[[3]])$AICc)
# gives you the info for the best-fit model
bestgrowth <- growth_models[[which(min_AIC == MuMIn::AICc(growth_models[[1]], growth_models[[2]], growth_models[[3]])$AICc)]]

# getting residuals of growth
size$growth_residuals <- NA
size$growth_residuals[which(!is.na(size$t1) & !is.na(size$t0))] <- summary(bestgrowth)$residuals^2


reproyesno_models <- list(glm(reproyesno~ t0, family= "binomial",data = size),
                          glm(reproyesno~ t0 + t0sq , family= "binomial",data =size))
# gives the value of the lowest AICc
min_AIC <- min(MuMIn::AICc(reproyesno_models[[1]], reproyesno_models[[2]])$AICc)
# gives you the info for the best-fit model
bestreproyesno <- reproyesno_models[[which(min_AIC == MuMIn::AICc(reproyesno_models[[1]], reproyesno_models[[2]])$AICc)]] 
# yes/no repro: logistic: 

# reproduction if reproducing: linear function of size, quadratic function of size, 
rep_models <- list(lm(bulbs0~ t0, data = sizeforrepro),
                   lm(bulbs0~ t0+ t0sq, data = sizeforrepro)) 
min_AIC <- min(MuMIn::AICc(rep_models[[1]], rep_models[[2]])$AICc)# gives the value of the lowest AICc
bestrep <- rep_models[[which(min_AIC == MuMIn::AICc(rep_models[[1]], rep_models[[2]])$AICc)]] # gives you the info for the best-fit model

# variance in growth: uses best-fit model for growth: linear function of size, quadratic function of size, no intercept
var_models <- list(glm(growth_residuals~ t0-1, data= size), glm(growth_residuals~ t0 + t0sq-1, data= size))
min_AIC <- min(MuMIn::AICc(var_models[[1]], var_models[[2]])$AICc) # gives the value of the lowest AICc
bestvar <- var_models[[which(min_AIC == MuMIn::AICc(var_models[[1]], var_models[[2]])$AICc)]] # gives you the info for the best-fit model

# vary bin sizes

lambdas_ipm_median <- vector("numeric", length= length(bin.num))
dampratio_median <- vector("numeric", length= length(bin.num))
lifespan_median = vector("numeric", length= length(bin.num))

truebinsizes= matrix(0,length(bin.num),1)

for (i in 1:length(bin.num)){

 vec.bin = c(minsize, minsize+1:bin.num[i]*(maxsize-minsize)*(1/bin.num[i])) 
  
  nums=hist(size$t0,breaks=vec.bin, plot=FALSE)$counts 
  
  #--- either do the first block to make medians the focal estimated size for each cat, or do the second line, to define as the mean of the breakpts:
  binmids =   rep(NA, length(vec.bin)-1)
  for(jj in 1:(length(vec.bin)-1)){
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    # subset <- size[size$t0 >= bounds[1] & size$t0 < bounds[2],]
    # binmids[jj] <- median(subset$t0)
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    
  }
  
  meanbinmids <- 0.5*(vec.bin[2:length(vec.bin)] + vec.bin[1:(length(vec.bin)-1)])
  binmids[is.na(binmids)]=meanbinmids[is.na(binmids)]
  # binmids[which(nums<=100)]=meanbinmids[which(nums<=100)]
  
  #--------------------------------------------------------------------
  
  
  n.bin = length(binmids)
  truebinsizes[i] = n.bin  
  
  # constructing matrix models
  indata <- as.data.frame(cbind(binmids, binmids^2))
  names(indata) <- c("t0", "t0sq")
  
  sur_vals <- predict(bestsur,indata, type='response')
  reproyesnovals=predict(bestreproyesno, indata, type='response')
  rep_vals <- predict(bestrep, indata, type='response')
  rep_vals[rep_vals<0] <- 0
  growth_vals <- predict(bestgrowth,indata, type='response')
  var_vals <- predict(bestvar,indata, type='response')
  gmx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
  
  sdlgszcdf=pnorm(vec.bin,mnsldgsz,sdsldgsz)
  sdlgszprobs=sdlgszcdf[2:length(vec.bin)]-sdlgszcdf[1:(length(vec.bin)-1)]
  sdlgszprobs=sdlgszprobs/sum(sdlgszprobs)
  
  # growth probs using cdf fn
  for (ss in 1:(n.bin)) {
    growcdf <- pnorm(vec.bin,growth_vals[ss],sqrt(var_vals[ss]))
    grows <- growcdf[2:length(vec.bin)]-growcdf[1:(length(vec.bin)-1)]
    if(sum(grows)>0){grows <- grows/sum(grows)
    gmx[,ss] <- grows} else {gmx[,ss] <- NA} 
    # this if statement breaks the code (puts NA's into the matrix) if the sum of the PDF is zero (which happens if all the probability is outside of the size bounds)
  } # end ss loop
  
  # make the surv*growth mx
  survgmx <- gmx*t(matrix( rep(sur_vals,(n.bin)),(n.bin))) # survs* growth
  reprow <- rep_vals*reproyesnovals #*bulblings_per_bulbil 
  
  mx1 <- survgmx # growth and survival, without the repro
  
  mx <- matrix(0, (n.bin+1), (n.bin+1))
  mx[2:(n.bin+1), 2:(n.bin+1)] = mx1
  mx[2:(n.bin+1),1] = surv_bulbings*sdlgszprobs
  
  mx[1,2:(n.bin+1)] = reprow*bulblings_per_bulbil  
  
  
    lambdas_ipm_median[i] <- Re(eigen(mx)$values[1])
    dampratio_median[i]= damping.ratio(mx)
    lifespan_median[i] =lifespan(mx)
  print(i)
}
mxmedian=mx

bistort.output.even <- as.data.frame(cbind(bin.num,lambdas_matrix, lambdas_ipm_mean,lambdas_ipm_median, dampratio_matrix,dampratio_mean,dampratio_median,lifespan_matrix,lifespan_mean,lifespan_median))
names(bistort.output.even) <- c("bin.num", 'lam.mx','lam,mn','lam.med','damp.mx','damp.mn','damp.med','life.mx','life.mn','life.med')
save(bistort.output.even,file='bistortevenout.RData')
```

##########################################
```{r}
# plotting
windows(4,8)
par(mfrow=c(3,1))#,pty= "s")
plot(truebinsizes,lambdas_matrix, type = 'b', xlab = "# of bins in model", main="bistorts with even breaks", col='blue', ylim=c(0.85,1.05))

points(truebinsizes,lambdas_ipm_median, type = 'b', xlab = "# of bins in model", col ='red')
linenames = expression(matrix,ipm)
points(truebinsizes,lambdas_ipm_mean, type = 'b', xlab = "# of bins in model", col ='red', lty=3, pch=8)
linenames = expression(matrix,ipm_median,ipm_mean)
legend("bottomright",linenames, lty=1, lwd=2, col=c('blue','red','red'),pch=c(1,1,8), cex=1.2)



# plotting lifespan

plot(truebinsizes,lifespan_matrix, type = 'b', xlab = "# of bins in model", main="bistorts with even breaks", col='blue', ylim=c(1,200))

points(truebinsizes,lifespan_median, type = 'b', xlab = "# of bins in model", col ='red')
linenames = expression(matrix,ipm)
points(truebinsizes,lifespan_mean, type = 'b', xlab = "# of bins in model", col ='red', lty=3, pch=8)
linenames = expression(matrix,ipm_median,ipm_mean)
#legend("topright",linenames, lty=1, lwd=2, col=c('blue','red','red'),pch=c(1,1,8), cex=1.2)

# plotting dampingratio

plot(truebinsizes,dampratio_matrix, type = 'b', xlab = "# of bins in model", main="bistorts with even breaks", col='blue', ylim=c(1,3))

points(truebinsizes,dampratio_median, type = 'b', xlab = "# of bins in model", col ='red')
linenames = expression(matrix,ipm)
points(truebinsizes,dampratio_mean, type = 'b', xlab = "# of bins in model", col ='red', lty=3, pch=8)
linenames = expression(matrix,ipm_median,ipm_mean)
#legend("topright",linenames, lty=1, lwd=2, col=c('blue','red','red'),pch=c(1,1,8), cex=1.2)